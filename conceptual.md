What is a JWT?
JWT (JSON Web Token), is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity-protected with a Message Authentication Code (MAC) and/or encrypted.


What is the signature portion of the JWT? What does it do?
The signature portion of a JWT is a cryptographic mechanism that secures the token. It is generated by taking the encoded header, the encoded payload, a secret, the algorithm specified in the header, and signing that. The signature ensures that the token has not been tampered with and, in cases where a private key is used to sign the token, it can also verify that the sender of the JWT is who it says it is.


If a JWT is intercepted, can the attacker see what's inside the payload?
Yes, if a JWT is intercepted, the attacker can see what's inside the payload because the payload is encoded and not encrypted. Encoding is a method of transforming data into another format using a scheme that is publicly available, meaning it can be easily reversed if the format is known. However, without the secret key, the attacker cannot alter the payload without invalidating the signature.


How can you implement authentication with a JWT? Describe how it works at a high level.
Authentication with JWT typically works as follows:


The user logs in with their credentials.
The server verifies the credentials and generates a JWT for the user, which includes claims about the user's identity and any other relevant data.
The server sends the JWT back to the client.
The client stores the JWT and includes it in the header of subsequent requests to protected routes.
The server verifies the JWT on each request to ensure it's valid and has not expired, then grants access to the protected resources.


Compare and contrast unit, integration, and end-to-end tests.
Unit Tests: Test individual components or functions in isolation from the rest of the application. They are quick to execute and help identify bugs at an early stage.
Integration Tests: Test the interaction between multiple components or systems, verifying that they work together as expected.
End-to-End Tests: Simulate real user scenarios from start to finish, testing the application as a whole. They are the most comprehensive but also the most time-consuming and resource-intensive to run.
What is a mock? What are some things you would mock?
A mock is an object that simulates the behavior of real objects in controlled ways. Mocks are typically used in unit testing to replicate the behavior of complex, real objects (like database connections or third-party services) when it's impractical or impossible to include them in the test. You would mock objects that are external to the component being tested, such as databases, APIs, or any other external service or system.


What is continuous integration?
Continuous Integration (CI) is a development practice where developers integrate code into a shared repository frequently, preferably several times a day. Each integration can then be verified by an automated build and automated tests. This approach helps to identify and fix integration errors quickly, improve software quality, and reduce the time it takes to validate and release new software updates.


What is an environment variable and what are they used for?
An environment variable is a dynamic-named value that can affect the way running processes will behave on a computer. They are used to configure the operating environment for software running on the machine, including paths to executable files, settings about the software environment, and configuration options. They can be used to avoid hard-coding database connection details, API keys, and other sensitive information into the application code.


What is TDD? What are some benefits and drawbacks?
Test-Driven Development (TDD) is a software development approach in which tests are written before the code that needs to be tested. The process follows a short repetitive cycle: write a test, run all tests and see the new one fail, write the code to pass the test, run tests again, refactor the code, and repeat. 
Benefits include improved code quality, detailed documentation through tests, and a design that’s more oriented towards testability. 
Drawbacks can include a steep learning curve, increased time upfront for writing tests, and the potential for overemphasis on unit testing at the expense of integration or system testing.


What is the value of using JSONSchema for validation?
JSONSchema is a powerful tool for validating the structure and format of JSON data. Using JSONSchema allows developers to precisely define the expected structure of JSON data, including object properties, data types, and other constraints. This helps ensure that the data adheres to a predefined format, reduces the likelihood of errors, and improves the reliability of systems that communicate or exchange data.


What are some ways to decide which code to test?
Deciding which code to test involves evaluating the complexity, criticality, and risk associated with different parts of the codebase. Priority should be given to:


Code that contains the core functionality
Components with a high risk of failure or those that have experienced frequent issues in the past.
New features or significant changes to existing functionality.
Areas of the code that are complex and have high business value.


What does RETURNING do in SQL? When would you use it?
The RETURNING clause in SQL is used with INSERT, UPDATE, DELETE, and sometimes MERGE operations to return values from the affected rows. This clause allows you to retrieve values from columns immediately after the operation without needing to execute a separate SELECT query. It is particularly useful for getting values generated by the database, like auto-incremented IDs or values affected by triggers.


What are some differences between Web Sockets and HTTP?
Connection: Web Sockets establish a persistent, full-duplex communication channel over a single TCP connection, allowing for real-time, bidirectional communication between the client and server. HTTP, in contrast, is a stateless protocol where each request opens a new connection (unless HTTP/2 or persistent connections are used).
Use Cases: Web Sockets are ideal for real-time applications like live chats and online games. HTTP is better suited for request-response applications, like web page retrieval and REST APIs.
Overhead: Web Sockets have lower overhead after the initial handshake, making them more efficient for frequent messages. HTTP has a higher overhead due to headers and stateless connections.


Did you prefer using Flask over Express? Why or why not?
I prefer both Flash and Express. Flask for its simplicity and the power of Python for certain types of applications, while Express for its performance in handling asynchronous operations and the vast npm ecosystem.